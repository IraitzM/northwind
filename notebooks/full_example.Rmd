---
title: "Building a RDBMS for a retail business"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook where several aspects involved on modeling a database will be explored.

For this notebook to work, one of the first things we will need to do is have a RDBMS system running. In particular, [PostgreSQL](https://www.postgresql.org/) will be used so you can download and install it or just user a docker image and instantiate an image for this demo using following commands:

To pull the image from the repository
* docker pull postgres

Container can be started, killed and restarted as many times as you want:

* docker run --name some-postgres -e POSTGRES_PASSWORD=postgres -d postgres
* docker kill some-postgres
* docker restart some-postgres

And its local IP address found using inspect command so we can connect and work with it:

* docker inspect some-postgres

Next thing, a bunch of libraries will be needed to run our code.

```{r}
renv::restore()
```

Also, auxiliary functions to ease the tasks need to be loaded.

```{r}
source('../src/aux_functions.R')
```

We have the RDBMS up and running and all libraries loaded to start working. Lets first connect to the database.

```{r}
dhost <- '172.17.0.2'

# Let's connect to our database
con <- DBI::dbConnect(RPostgres::Postgres(), 
                      user= 'postgres', 
                      password = 'postgres', 
                      host=dhost)

# List existing tables
list(con)
```

Ok, empty! Let's start creating our data schema so we can then support our business processes and manage the data they need and generate.

```{r}
# Customers
q <- 'CREATE TABLE customers (
    customerid bpchar NOT NULL,
    companyname character varying(40) NOT NULL,
    contactname character varying(30),
    contacttitle character varying(30),
    address character varying(60),
    city character varying(30),
    region character varying(30),
    postalcode character varying(10),
    country character varying(30),
    phone character varying(24),
    fax character varying(24)
);'
exec(con,q)
show(con)
```

It works, lets do the rest.

```{r}
# Employees
q <- 'CREATE TABLE employees (
    employeeid smallint NOT NULL,
    lastname character varying(20) NOT NULL,
    firstname character varying(10) NOT NULL,
    title character varying(30),
    titleofcourtesy character varying(25),
    birthdate date,
    hiredate date,
    address character varying(60),
    city character varying(15),
    region character varying(15),
    postalcode character varying(10),
    country character varying(15),
    homephone character varying(24),
    extension character varying(4),
    photo bytea,
    notes text,
    reportsto smallint,
    photopath character varying(255)
);'
exec(con, q)

# Order details
q <- 'CREATE TABLE order_details (
    orderid smallint NOT NULL,
    productid smallint NOT NULL,
    unitprice real NOT NULL,
    quantity smallint NOT NULL,
    discount real NOT NULL
);'
exec(con, q)

# Orders
q <- 'CREATE TABLE orders (
    orderid smallint NOT NULL,
    customerid bpchar,
    employeeid smallint,
    orderdate date,
    requireddate date,
    shippeddate date,
    shipvia smallint,
    freight real
);'
exec(con, q)

# Products
q <- 'CREATE TABLE products (
    productid smallint NOT NULL,
    productname character varying(40) NOT NULL,
    supplierid smallint,
    categoryid smallint,
    quantityperunit character varying(20),
    unitprice real,
    unitsinstock smallint,
    unitsonorder smallint,
    reorderlevel smallint,
    discontinued integer NOT NULL
);'
exec(con, q)

# List existing tables
list(con)
```

So, once relations are there we can start putting the constraint that will help as have a consistent data model for our retail business. First the Primery Keys for our relations/tables.

```{r}
# Add PK to customers
q <-'ALTER TABLE ONLY customers
ADD CONSTRAINT pk_customers PRIMARY KEY (customerid);'
exec(con, q)

# Add PK to employees
q <-'ALTER TABLE ONLY employees
ADD CONSTRAINT pk_employees PRIMARY KEY (employeeid);'
exec(con, q)

# Add composed PK to order_details
q <-'ALTER TABLE ONLY order_details
ADD CONSTRAINT pk_order_details PRIMARY KEY (orderid, productid);'
exec(con, q)

# Add PK to orders
q <-'ALTER TABLE ONLY orders
ADD CONSTRAINT pk_orders PRIMARY KEY (orderid);'
exec(con, q)

# Add PK to products
q <-'ALTER TABLE ONLY products
ADD CONSTRAINT pk_products PRIMARY KEY (productid);'
exec(con, q)
```

Now let's relate the Keys found in the rest of the tables to the row the refer to.

```{r}
# Now relate FKs orders.customerid with customers
q <-'ALTER TABLE ONLY orders
ADD CONSTRAINT fk_orders_customers FOREIGN KEY (customerid) REFERENCES customers;'
exec(con, q)

# Now relate FKs orders.employeeid with employees
q <-'ALTER TABLE ONLY orders
ADD CONSTRAINT fk_orders_employees FOREIGN KEY (employeeid) REFERENCES employees;'
exec(con, q)

# Now relate FKs order_details.productid with products
q <-'ALTER TABLE ONLY order_details
ADD CONSTRAINT fk_order_details_products FOREIGN KEY (productid) REFERENCES products;'
exec(con, q)

# Now relate FKs order_details.orderid with orders
q <-'ALTER TABLE ONLY order_details
ADD CONSTRAINT fk_order_details_orders FOREIGN KEY (orderid) REFERENCES orders;'
exec(con, q)
```

Good! Our schema should be complete by now. Let's check.

```{r}
show(con)
```

Now that our model is complete we can use it for some data manipulation. Inserting a customer for example.

```{r}
exec(con, "INSERT INTO customers(customerid, companyname) VALUES (1, 'Deusto')")
```

And show how our information is there.

```{r}
query(con, "SELECT * FROM customers")
```
Update the information on that tuple.
```{r}
exec(con, "UPDATE customers SET contactname = 'Iraitz' WHERE companyname = 'Deusto'")
query(con, "SELECT * FROM customers")
```
And check if our constraints do their work.
```{r}
exec(con, "INSERT INTO customers(customerid, companyname) VALUES (1, 'Deusto')")
```

Or just delete the information.
```{r}
exec(con, "DELETE FROM customers WHERE companyname = 'Deusto'")
query(con, "SELECT * FROM customers")
```

Let's clean everything up and disconnect from the database.

```{r}
clearDB(con)
DBI::dbDisconnect(con)
```

